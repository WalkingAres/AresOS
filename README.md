# AresOS

## 简易的原型操作系统（保护模式）

### 主引导扇区程序和内核加载

这部分内容主要使用汇编语言完成，主要借鉴了《Orange‘s：一个操作系统的实现》，使用FAT12文件系统的格式管理内核加载器（loader）和内核城区（kernel）。主引导扇区程序，把loader从软盘中读取到指定的内存地址上，然后跳转到加载程序。在加载程序实现内核加载、开启保护模式，最后使用一条跳转指令实现内核程序的运行。

#### 进入保护模式

在系统启动，从实模式进入保护模式之前，还有几件初始化的事情需要完成。

1. 全局描述符表（Global Descriptor Table，GDT）

   在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此积存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。

   在AresOS系统中，初始化了三个段描述符

   - 4GB的代码段
   - 4GB的可读写段
   - 显存段，用于屏幕字符显示控制

2. 打开A20地址线

   在实模式在，一共只有20为地址线A0~A19，A20是关闭的。保护模式是32位寻址，A0—A31，需要打开默认关闭的A20地址线。

3. 打开CR0控制寄存器的PE控制位（保护模式允许位）

4. 跳转进入保护模式

在实模式下，CS、DS、ES、FS、GS、SS的段寄存器（存储高位地址）。在保护模式中加做段选择器，存储段选择子，指明在GDT或LDT表中段描述符，段描述符中有起始基址和段的界限。

### 内核程序

从实模式进入保护模式之后，还有很多需要初始化的内容。首先是要切换栈，我们通过一个跳转指令jmp，转到内核程序，但栈还在原来的内存空间。我们需要自己开辟一片空间，系统自己维护，作为系统的内核栈使用。

1. 把之前的GDT的内容移动到，我们自己规定的内存位置，修改GDTR的内容，方便系统管理。
2. 进入保护模式后，实模式下的中断例程不再适用，需要重新编写初始化相应的中断例程，初始化IDT。
3. 初始化任务寄存器

### 中断例程

中断机制的实现使得CPU可以实现高并发运行程序和处理I/O的能力。中断分为硬中断和软中断。硬中断由8259A等芯片负责向CPU发出中断请求，软中断通过指令int n实现。

前文说过，进入保护模式后实模式下的中断例程无法再使用，需要重新编写。编写一个中断例程，除了完成中断的相应功能之外，还要能够在中断返回后，系统能够继续正常运行（就像没有被打断一样），其中涉及到最重要的不走就是保护现场和恢复现场。

保护现场，就是使用保存当前进程的运行状态，包括当前进程的上下文信息（当前CPU各个寄存器的值、状态寄存器信息等）（save（））

恢复现场就是把之前保存的值恢复，使得被中断的进程能够继续正常的运行。（restart（））

AresOS系统中实现了时钟中断、键盘中断和系统调用（fork、exit、wait、execv），其中系统调用的实现参考了linux的系统调用实现。

### 进程模型

在AresOS系统中，一个进程除了代码数据之外，更重要的是进程控制块（PCB），PCB在多进程模型中，对进程切换起着重要的作用。PCB主要由进程的寄存器信息、LDT、LDT选择子、进程状态、进程id、进程名称、进程优先级、进程的栈空间和父进程、子进程等内容构成。

**进程状态**：

ALIVE：正在运行；READY：就绪态；SLEEP：阻塞态；DIED：终止态；

参照五状态进程模型进行切换。

参照linux系统，在内核开始运行之初，只有一个进程号为0的进程在运行，其余进程都是fork派生出来的子进程。

### 内存管理

内存管理采用了简单的链式管理的方式。一开始有一块完整的内存空间，每次用户申请内存，系统就根据用户需求分配内存空间。每次分配出去的内存空间有一个头部信息，存储分配内存块的大小等信息，便于系统回收时，知道回收内存空间的大小。

**注：主要文件目录备注**

boot/boot.asm 主引导扇区程序

boot/loader.asm 加载器程序

include/* 有关进程定义、标准输入输出函数定义等

kernel/interrupt/* 中断例程

kernel/lib/* 内核库函数 如显存显示字符、系统调用

kernel/* 内核初始化

mm/* 内存管理 malloc、free函数
